{-# START_FILE package.yaml #-}
name:                {{name}}
version:             0.1.0.0
description:         "{{name}}"

dependencies:
- base >= 4.7 && < 5
- text
- containers
- unordered-containers
- hashable
- vector
- split
- safe
- either
- megaparsec
- optparse-applicative
- witherable
- neat-interpolation
- recursion-schemes
- data-fix
- pretty
- comonad
- distributive
- adjunctions
- machines
- algebraic-graphs
- ansi-terminal
- envparse
- req
- bytestring
- mtl
- aeson
- aeson-pretty
- array

default-extensions:
- OverloadedStrings

ghc-options:
  - -Wall
  - -Wincomplete-record-updates
  - -Wincomplete-uni-patterns
  - -Wredundant-constraints
  - -Wunused-packages
  - -O2

library:
  source-dirs: src

executables:
  {{name}}:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}

tests:
  {{name}}-test:
    main:                Spec.hs
    source-dirs:         test
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    - -O0 # No optimisation for faster test runs
    dependencies:
    - {{name}}
    - hspec
    - hspec-discover
    - QuickCheck
    build-tools:
    - hspec-discover

benchmarks:
  {{name}}-benchmarks:
    main: Main.hs
    source-dirs: benchmarks
    ghc-options:
      - -O2
      - -threaded
      - -rtsopts
      - -with-rtsopts=-s
    dependencies:
      - {{name}}
      - base
      - criterion

verbatim:
  cabal-version: 3.0

{-# START_FILE app/Main.hs #-}
module Main where

import App

main :: IO ()
main = program

{-# START_FILE src/App.hs #-}
module App where

import Args (
  Args (Args),
  Command (..),
  GenerateArgs (GenerateArgs),
  StatsArgs (StatsArgs),
  parseArgs,
  readInput,
 )
import CodeGenerator (program)
import qualified Data.Text as T
import Options.Applicative (handleParseResult)
import Solutions (solutions)
import Stats (program)
import System.Environment (getArgs)

program :: IO ()
program =
  getArgs >>= (handleParseResult . parseArgs) >>= program'

program' :: Command -> IO ()
program' (Run (Args n input)) = readInput input >>= runSolution n
program' (Generate (GenerateArgs d)) = CodeGenerator.program d
program' (GetStats (StatsArgs year export)) = Stats.program year export

runSolution :: Int -> T.Text -> IO ()
runSolution day input = case solution day of
  Just solve -> solve input
  Nothing -> putStrLn "day not found"

solution :: Int -> Maybe (T.Text -> IO ())
solution day
  | day >= 1 && day <= length solutions = Just (solutions !! (day - 1))
  | otherwise = Nothing

{-# START_FILE src/Stats.hs #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingVia #-}

module Stats where

import Args (StatsRender (..))
import Control.Monad ((<=<))
import Control.Monad.Except (ExceptT (..), runExceptT)
import Data.Aeson (ToJSON, toJSON)
import Data.Aeson.Encode.Pretty (Config (..), Indent (Spaces), defConfig, encodePretty')
import Data.Aeson.Types (Value)
import Data.Bifunctor (first)
import qualified Data.ByteString.Char8 as B8
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Text.IO as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TLE
import Data.Void (Void)
import qualified Env
import GHC.Generics (Generic)
import Network.HTTP.Req (
  GET (GET),
  NoReqBody (NoReqBody),
  bsResponse,
  defaultHttpConfig,
  header,
  https,
  req,
  responseBody,
  responseStatusCode,
  runReq,
  (/:),
 )
import System.Exit (exitFailure, exitSuccess)
import Text.Megaparsec (MonadParsec (try), Parsec, anySingle, errorBundlePretty, manyTill, runParser)
import Text.Megaparsec.Char (char, string)
import Text.Megaparsec.Char.Lexer (decimal)
import Text.Megaparsec.Error (ParseErrorBundle)

newtype StarsCount = StarsCount {count :: Int}
  deriving (Eq, Show, Num) via Int

newtype Stats = Stats {starsCount :: StarsCount}
  deriving (Eq, Show)

renderSuccessOrError :: StatsRender -> Either StatsError Stats -> T.Text
renderSuccessOrError _ (Left (Not200 s)) = T.pack ("Unexpected HTTP status code response: " ++ show s)
renderSuccessOrError _ (Left (CannotFindNumberOfStars p)) = T.pack (errorBundlePretty p)
renderSuccessOrError ConsoleRender (Right stats) = consoleRender stats
renderSuccessOrError JsonRender (Right stats) = jsonRender stats

consoleRender :: Stats -> T.Text
consoleRender =
  ("stars:" <>)
    . T.pack
    . show
    . count
    . starsCount

jsonToText :: Value -> T.Text
jsonToText = TL.toStrict . TLE.decodeUtf8 . encodePretty' config where
 config = defConfig { confIndent = Spaces 2 }

jsonRender :: Stats -> T.Text
jsonRender = jsonToText . toJSON . toShieldConfig

newtype StatsEnvVariables = StatsEnvVariables
  {session :: String}
  deriving (Eq, Show)

data ShieldsConfig = ShieldsConfig
  { schemaVersion :: Int
  , label :: String
  , message :: String
  , color :: String
  }
  deriving (Eq, Show, Generic)

instance ToJSON ShieldsConfig

defaultShieldsConfig :: String -> ShieldsConfig
defaultShieldsConfig m =
  ShieldsConfig
    { schemaVersion = 1
    , label = "stars ⭐️"
    , message = m
    , color = "green"
    }

toShieldConfig :: Stats -> ShieldsConfig
toShieldConfig =
  defaultShieldsConfig
    . show
    . count
    . starsCount

data StatsError
  = Not200 Int
  | CannotFindNumberOfStars ParsingError
  deriving (Eq, Show)

statsEnvVariablesParser :: Env.Parser Env.Error StatsEnvVariables
statsEnvVariablesParser =
  StatsEnvVariables
    <$> Env.var (Env.str <=< Env.nonempty) "AOC_SESSION" (Env.help "Value of the session cookie, used for login")

program :: Int -> StatsRender -> IO ()
program year render = do
  config <- Env.parse (Env.header "AOC stats requires env variables") statsEnvVariablesParser
  stats <- runExceptT $ program' year config
  T.putStrLn (renderSuccessOrError render stats) *> exit stats
 where
  exit (Left _) = exitFailure
  exit (Right _) = exitSuccess

program' :: Int -> StatsEnvVariables -> ExceptT StatsError IO Stats
program' year envVariables =
  ExceptT (uncurry parseIf200 <$> fetchPage year (session envVariables))

parseIf200 :: Int -> T.Text -> Either StatsError Stats
parseIf200 200 = first CannotFindNumberOfStars . parse
parseIf200 status = const (Left (Not200 status))

fetchPage :: Int -> String -> IO (Int, T.Text)
fetchPage year s = runReq defaultHttpConfig $ do
  let url = https "adventofcode.com" /: T.pack (show year)
      cookieHeader = B8.pack ("session=" ++ s)
  response <- req GET url NoReqBody bsResponse (header "Cookie" cookieHeader)
  let body = TE.decodeUtf8 $ responseBody response
      status = responseStatusCode response
  pure (status, body)

-- parsing
type Parser = Parsec Void T.Text
type ParsingError = ParseErrorBundle T.Text Void

starsCountParser :: Parser StarsCount
starsCountParser =
  StarsCount
    <$> ( manyTill anySingle (try (string "<span class=\"star-count\">"))
            *> decimal
            <* char '*'
            <* string "</span>"
        )

statsParser :: Parser Stats
statsParser = Stats <$> starsCountParser

parse :: T.Text -> Either ParsingError Stats
parse = runParser statsParser "html"
{-# START_FILE src/CodeGenerator.hs #-}
module CodeGenerator where

program :: Int -> IO()
program _ = putStrLn "not implemented yet"
{-# START_FILE src/Solutions.hs #-}
module Solutions where

import qualified Data.Text as T
import Day1 (program)
import Day2 (program)
import Day3 (program)
import Day4 (program)
import Day5 (program)
import Day6 (program)
import Day7 (program)
import Day8 (program)
import Day9 (program)
import Day10 (program)

solutions :: [T.Text -> IO ()]
solutions =
  [ Day1.program
  , Day2.program
  , Day3.program
  , Day4.program
  , Day5.program
  , Day6.program
  , Day7.program
  , Day8.program
  , Day9.program
  , Day10.program
  ]
{-# START_FILE src/Args.hs #-}
module Args where

import qualified Data.Text as T
import qualified Data.Text.IO as T
import Options.Applicative

data Command
  = Run Args
  | Generate GenerateArgs
  | GetStats StatsArgs
  deriving (Eq, Show)

data Args = Args
  { day :: Int
  , input :: DayInput
  }
  deriving (Eq, Show)

data DayInput = FromFile FilePath | FromStdInput deriving (Eq, Show)

readInput :: DayInput -> IO T.Text
readInput (FromFile f) = T.readFile f
readInput FromStdInput = T.getContents

dayInputParser :: Parser DayInput
dayInputParser = fromFileParser <|> fromStdInputParser
 where
  fromFileParser =
    FromFile
      <$> strOption
        ( long "filename"
            <> short 'f'
            <> help "Read input from the specified file"
        )
  fromStdInputParser =
    flag'
      FromStdInput
      ( long "with-input"
          <> help "Read input from standard input"
      )

newtype GenerateArgs = GenerateArgs Int deriving (Eq, Show)
data StatsRender = ConsoleRender | JsonRender deriving (Eq, Show)
data StatsArgs = StatsArgs Int StatsRender deriving (Eq, Show)

argsParser :: Parser Args
argsParser =
  Args
    <$> option
      auto
      ( long "day"
          <> short 'd'
          <> help "day"
      )
    <*> dayInputParser

generateArgsParser :: Parser GenerateArgs
generateArgsParser =
  GenerateArgs
    <$> option
      auto
      ( long "day"
          <> short 'd'
          <> help "day"
      )
statsArgsParser :: Parser StatsArgs
statsArgsParser =
  StatsArgs
    <$> option
      auto
      ( long "year"
          <> short 'y'
          <> value 2024
          <> showDefault
          <> help "year"
      )
    <*> flag
      ConsoleRender
      JsonRender
      ( long "json"
          <> help "Export as json"
      )

commandParser :: Parser Command
commandParser =
  hsubparser
    ( command "run" (info (Run <$> argsParser) (progDesc "run the solution to the puzzle"))
        <> command "generate" (info (Generate <$> generateArgsParser) (progDesc "generate scaffolding from template for a given day"))
        <> command "stats" (info (GetStats <$> statsArgsParser) (progDesc "retrieve stats from the AOC website"))
    )

withInfo :: Parser a -> String -> ParserInfo a
withInfo p s = info (helper <*> p) (fullDesc <> progDesc s)

parseArgs :: [String] -> ParserResult Command
parseArgs = execParserPure preferences parserInfo
 where
  parserInfo = withInfo commandParser "Advent of code 2024 CLI"
  preferences = prefs (disambiguate <> showHelpOnEmpty <> showHelpOnError)
{-# START_FILE src/Day1.hs #-}
module Day1 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day2.hs #-}
module Day2 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day3.hs #-}
module Day3 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day4.hs #-}
module Day4 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day5.hs #-}
module Day5 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day6.hs #-}
module Day6 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day7.hs #-}
module Day7 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day8.hs #-}
module Day8 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day9.hs #-}
module Day9 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/Day10.hs #-}
module Day10 where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE src/DayN.hs #-}
module DayN where
import qualified Data.Text as T
import qualified Data.Text.IO as T

data Answer = Answer deriving (Eq, Show)

program :: T.Text -> IO ()
program = print . logic

logic :: T.Text -> Answer
logic = const Answer
{-# START_FILE test/Spec.hs #-}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
{-# START_FILE test/SpecHook.hs #-}
module SpecHook where

import Test.Hspec ( parallel, Spec )

hook :: Spec -> Spec
hook = parallel
{-# START_FILE test/AppSpec.hs #-}
module AppSpec where

import App
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck.Property

spec :: Spec
spec = describe "Simple test" $ do

     it "example-based unit test" $
        1 `shouldBe` 1

     prop "property-based unit test" $
        \l -> reverse ( reverse l ) == ( l::[Int])

{-# START_FILE test/ArgsSpec.hs #-}
module ArgsSpec where

import Args
import Options.Applicative (ParserResult (Failure, Success))
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck.Property

parseArgsMaybe = transform . parseArgs
 where
  transform (Success a) = Right a
  transform (Failure failure) = Left (show failure)
  transform _ = Left "completion"

spec :: Spec
spec = describe "Args parser" $ do
  it "is able to parse a valid command to run the solution from file" $
    parseArgsMaybe ["run", "-d", "1", "-f", "file"] `shouldBe` Right (Run (Args 1 (FromFile "file")))

  it "is able to parse a valid command to run the solution from standard input" $
    parseArgsMaybe ["run", "-d", "1", "--with-input"] `shouldBe` Right (Run (Args 1 FromStdInput))

  it "is able to parse a valid command to generate the scaffolding for a new day" $
    parseArgsMaybe ["generate", "-d", "1"] `shouldBe` Right (Generate (GenerateArgs 1))

  it "is able to parse a valid command to retrieve stats (without export)" $
    parseArgsMaybe ["stats", "-y", "2022"] `shouldBe` Right (GetStats (StatsArgs 2022 ConsoleRender))

  it "is able to parse a valid command to retrieve stats (with export)" $
    parseArgsMaybe ["stats", "-y", "2022", "--json"] `shouldBe` Right (GetStats (StatsArgs 2022 JsonRender))

  it "is able to parse a valid command to retrieve stats (with export and without year)" $
    parseArgsMaybe ["stats", "--json"] `shouldBe` Right (GetStats (StatsArgs 2024 JsonRender))
{-# START_FILE test/Day1Spec.hs #-}
module Day1Spec where

import Day1
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 1" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input1"
     logic input `shouldBe` Answer
{-# START_FILE test/Day2Spec.hs #-}
module Day2Spec where

import Day2
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 2" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input2"
     logic input `shouldBe` Answer
{-# START_FILE test/Day3Spec.hs #-}
module Day3Spec where

import Day3
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 3" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input3"
     logic input `shouldBe` Answer
{-# START_FILE test/Day4Spec.hs #-}
module Day4Spec where

import Day4
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 4" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input4"
     logic input `shouldBe` Answer
{-# START_FILE test/Day5Spec.hs #-}
module Day5Spec where

import Day5
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input5"
     logic input `shouldBe` Answer
{-# START_FILE test/Day6Spec.hs #-}
module Day6Spec where

import Day6
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input6"
     logic input `shouldBe` Answer
{-# START_FILE test/Day7Spec.hs #-}
module Day7Spec where

import Day7
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input7"
     logic input `shouldBe` Answer
{-# START_FILE test/Day8Spec.hs #-}
module Day8Spec where

import Day8
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input8"
     logic input `shouldBe` Answer
{-# START_FILE test/Day9Spec.hs #-}
module Day9Spec where

import Day9
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input9"
     logic input `shouldBe` Answer
{-# START_FILE test/Day10Spec.hs #-}
module Day10Spec where

import Day10
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day 5" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/input10"
     logic input `shouldBe` Answer
{-# START_FILE test/DayNSpec.hs #-}
module DayNSpec where

import DayN
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import qualified Data.Text as T
import qualified Data.Text.IO as T

spec :: Spec
spec = describe "Day N" $ do
  it ""
    $ 1
    `shouldBe` 1

  prop ""
    $ \l -> reverse (reverse l) == (l :: [Int])

  xit "solve the puzzle" $ do
     input <- T.readFile "resources/inputN"
     logic input `shouldBe` Answer
{-# START_FILE README.md #-}
# {{name}}

## How to build and run locally

The project uses the [Haskell tool stack](https://docs.haskellstack.org/en/stable/README/). The recommended way to install stack is by using [ghcup](https://www.haskell.org/ghcup/).
It's also possible to use [the nix package manager](https://nixos.org/), but this project does not provide a nix configuration file.

Assuming `stack` is installed in the system, to **build** the project use
```
stack build
```
To **build and run the tests**, run
```
stack test
```
or equivalently
```
stack build --test
```
For **faster feedback loop** during development, it's possible to run tests continuously on every file change:
```
stack test --fast --file-watch
```
To run tests with **test coverage** instrumentation,
```
stack test --coverage
```
which generates a textual and HTML report.

Note: Tests are run in the CI and test coverage reports are automatically uploaded to codecov.

To **run** the executable via slack,
```
stack exec {{name}}
```
or passing arguments
```
stack exec {{name}} -- -d <day> -f <filename>
```

To **install** the executable under `~/.local/bin`,
```
stack install
```
and the executable can be run with `{{name}}` assuming `~/.local/bin` is in the `$PATH` variable.

To run a version of **ghci** compatible with the resolver
```
stack ghci
```
For more information about how to use `stack`, refer to the [official docs](https://docs.haskellstack.org/en/stable/).

This projects uses [optparse-applicative](https://hackage.haskell.org/package/optparse-applicative) to implement command-line arguments parsing. Optparse-applicative automatically generates an helper from code. It's recommended to use the generated helper to explore all the available CLI options.
{-# START_FILE .github/workflows/ci.yml #-}
{{=<% %>=}}
name: Compile and run tests

on:
  push:
    branches: [ main, feature/** ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # enable manual execution

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  stack:

    name: ${{ matrix.os }} / ghc ${{ matrix.ghc }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        stack: ["3.7.1"]
        ghc: ["9.10.3"]

    steps:

    - name: Checkout repo
      uses: actions/checkout@v6

    - name: Cache stack installation
      uses: actions/cache@v4
      with:
        path: |
          ~/.stack/build-plan
          ~/.stack/indices
          ~/.stack/snapshots
          ~/.stack/global-project/.stack-work/install
        key: ${{ runner.os }}-ghc-${{ matrix.ghc }}-stack-${{ matrix.stack }}-${{ hashFiles('stack.yaml', 'stack.yaml.lock') }}
        restore-keys: |
          ${{ runner.os }}-ghc-${{ matrix.ghc }}-stack-${{ matrix.stack }}-

    - name: Cache GHC installation
      uses: actions/cache@v4
      with:
        path: |
          ~/.ghcup/ghc/${{ matrix.ghc }}
          ~/.ghcup/bin/stack-${{ matrix.stack }}
        key: ${{ runner.os }}-ghc-${{ matrix.ghc }}-stack-${{ matrix.stack }}

    - name: Setup Haskell Stack
      uses: haskell-actions/setup@v2
      with:
        ghc-version: ${{ matrix.ghc }}
        stack-version: ${{ matrix.stack }}
        enable-stack: true

    - name: Install dependencies
      if: steps.cache.outputs.cache-hit != 'true' && success()
      timeout-minutes: 15
      run: |
        stack build --system-ghc --test --no-run-tests --only-dependencies

    - name: Run tests with coverage
      timeout-minutes: 15
      run: |
        stack test --system-ghc --test --coverage --fast

    - name: Build
      timeout-minutes: 15
      run: |
        stack build --system-ghc --test --no-run-tests

    - name: Generate coverage report
      uses: 8c6794b6/hpc-codecov-action@v4
      with:
        target: stack:<%name%>-test
        out: ./codecov.json
        verbose: true

    - name: Send coverage report
      uses: codecov/codecov-action@v5
      with:
        files: ./codecov.json
        fail_ci_if_error: false # optional (default = false)
        verbose: true
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
<%={{ }}=%>
{-# START_FILE .gitignore #-}
# Stack
.stack-work/
.stack/
*~
*.swp
*.swo
.DS_Store
# IDE
.idea/
# Aux files
*.o
*.hi
*.hie
*.chi
*.chs.h
*.dyn_o
*.dyn_hi
*.prof
*.aux
*.hp
*.eventlog
{{name}}.cabal
hls.log
cabal.project.local
cabal.project.local~
.ghc.environment.*
